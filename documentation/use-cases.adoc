== Use Cases

All use cases of this application rely on the same usecase unspecific abstractions in different layers of the application.
The layers are organized as follows:

[graphviz,application-layers,svg]
....
digraph layers {
    rankdir = RL;

    "Use case" -> Domain
    Adapter -> "Use case"
    Adapter -> Domain
}
....

The abstractions used to implement a use case are:

* Endpoint -> an adapter for the use case which is called by a client of the application to trigger the use case
** Endpoint Input -> parses and validates inputs of the client, i.e. ensures that the client's request is a valid input for the use case
** Endpoint Output -> validates and converts the output of a use case into a response to the client's request
* Use case -> called by some endpoint to execute a use case with a valid input.
Uses domain operations to execute some useful functionality.
** Use case input -> specifies the acceptable input to the use case
** Use case output -> specifies the output produced by the use case
* Entity -> defines the application's data structures and the validation rules which ensure only valid instances of entities can be instantiated
* Domain operation -> defines the operations which can be applied to the application's data structures
* Repository -> an adapter for the domain operations which ensures that changes of domain operations to the application's data structures is persisted in some form

The following diagrams how these abstractions collaborate in order to execute a client's request resp. a use case:

[plantuml,login-sequence,svg]
....
@startuml
title Collaboration of abstractions to execute a use case
autonumber

actor Client
boundary "Use Case Input"
boundary "Domain Operations"

box "Endpoint" #99b1ff
    participant Endpoint
    participant "Endpoint Input"
end box

box "Use Cases" #ffe0af
    participant "Use Case Input"
    participant "Use Case"
    participant "Domain Operations"
end box

box "Persistence Adapter" #d0ffd5
    participant Repositories
end box


Repositories -> "Domain Operations" **: <<create>>

activate "Use Case"
"Use Case" -> "Use Case": <<constructor>>
"Domain Operations" -> "Use Case" : <<inject>>
"Use Case" -> "Use Case Input" **: <<create>>
deactivate "Use Case"

activate Endpoint
Endpoint -> Endpoint: <<constructor>>
"Use Case Input" -> Endpoint : <<inject>>
deactivate Endpoint

Client -> Endpoint: call
activate Endpoint
note left: Client want to execute some use case and provides the required input
Endpoint -> "Endpoint Input" **: <<create>>
Endpoint -> "Endpoint Input": request()
activate "Endpoint Input"
return Use Case Input


Endpoint -> "Use Case Input": apply(Use Case Input)

"Use Case Input" -> "Use Case": apply(Use Case Input)
activate "Use Case"
note right: Use case logic

"Use Case" -> "Domain Operations": execute

"Domain Operations" -> "Repositories": execute
activate Repositories
return Entity

"Domain Operations" -> "Use Case": execute

return Use Case Output

"Use Case Input" --> Endpoint: Use Case Output

return "Endpoint Output"

@enduml
....